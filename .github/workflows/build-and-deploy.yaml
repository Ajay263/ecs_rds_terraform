name: Deploy to Amazon ECS

on:
  workflow_dispatch:
  push:
    branches:
      - main
      - prod

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: ecr-repo-ecs-tf-project
  AWS_ACCOUNT_ID: 651706742043

jobs:
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.set-tag.outputs.tag }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set image tag
        id: set-tag
        run: echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.set-tag.outputs.tag }}
        run: |
          docker buildx build \
            --platform "linux/amd64" \
            --tag "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" \
            --load \
            .
          
          docker push "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          echo "✅ Image pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/main'
    environment: staging
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set deployment variables
        id: vars
        run: |
          echo "cluster=staging" >> $GITHUB_OUTPUT
          echo "service=staging-service" >> $GITHUB_OUTPUT

      - name: Pull Docker image
        env:
          IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
        run: |
          docker pull ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG

      - name: Promote image tag to staging
        env:
          IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
        run: |
          echo "Tagging image $IMAGE_TAG as staging"
          
          docker pull ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG

          docker tag \
            ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG \
            ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:staging

          docker push \
            ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:staging
          
          echo "✅ Image promoted to staging tag"

      - name: Run database migrations
        env:
          IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
          CLUSTER_NAME: ${{ steps.vars.outputs.cluster }}
          SERVICE_NAME: ${{ steps.vars.outputs.service }}
        run: |
          # Option 1: Fetch from SSM and pass as environment variable (current approach)
          DB_STRING=$(aws ssm get-parameter \
            --name "/staging/service/postgres-url" \
            --with-decryption \
            --query 'Parameter.Value' \
            --output text)

          if [ -z "$DB_STRING" ]; then
            echo "❌ Failed to retrieve database connection string from SSM"
            exit 1
          fi

          echo "✅ Retrieved database connection string from SSM"

          # Create overrides file with environment variables
          cat > overrides.json <<EOF
          {
            "containerOverrides": [
              {
                "name": "service",
                "environment": [
                  { "name": "GOOSE_DRIVER", "value": "postgres" },
                  { "name": "GOOSE_DBSTRING", "value": "${DB_STRING}" }
                ],
                "command": ["goose", "-dir", "migrations", "up"]
              }
            ]
          }
          EOF
          
          # Alternative Option 2: Use ECS secrets (more secure - uncomment to use)
          # This requires your task execution role to have ssm:GetParameters permission
          # cat > overrides.json <<EOF
          # {
          #   "containerOverrides": [
          #     {
          #       "name": "service",
          #       "environment": [
          #         { "name": "GOOSE_DRIVER", "value": "postgres" }
          #       ],
          #       "secrets": [
          #         {
          #           "name": "GOOSE_DBSTRING",
          #           "valueFrom": "/staging/service/postgres-url"
          #         }
          #       ],
          #       "command": ["goose", "-dir", "migrations", "up"]
          #     }
          #   ]
          # }
          # EOF

          echo "Starting migration task..."
          
          # Run the migration task
          TASK_ARN=$(aws ecs run-task \
            --cluster "${CLUSTER_NAME}" \
            --task-definition "${SERVICE_NAME}" \
            --launch-type EC2 \
            --overrides file://overrides.json \
            --query 'tasks[0].taskArn' \
            --output text)

          echo "Migration task ARN: ${TASK_ARN}"

          # Check if task was created successfully
          if [ "$TASK_ARN" == "None" ] || [ -z "$TASK_ARN" ]; then
            echo "❌ Failed to start migration task"
            exit 1
          fi

          # Wait for the task to complete
          echo "Waiting for migration task to complete..."
          aws ecs wait tasks-stopped \
            --cluster "${CLUSTER_NAME}" \
            --tasks "${TASK_ARN}"

          # Get task exit code
          TASK_INFO=$(aws ecs describe-tasks \
            --cluster "${CLUSTER_NAME}" \
            --tasks "${TASK_ARN}")

          EXIT_CODE=$(echo "$TASK_INFO" | jq -r '.tasks[0].containers[0].exitCode // "None"')
          STOPPED_REASON=$(echo "$TASK_INFO" | jq -r '.tasks[0].stoppedReason // "Unknown"')
          LAST_STATUS=$(echo "$TASK_INFO" | jq -r '.tasks[0].lastStatus // "Unknown"')

          echo "Task Status: ${LAST_STATUS}"
          echo "Exit Code: ${EXIT_CODE}"
          echo "Stopped Reason: ${STOPPED_REASON}"

          # Check for task failure
          if [ "$EXIT_CODE" == "None" ] || [ "$EXIT_CODE" != "0" ]; then
            echo "❌ Migration failed"
            echo "Task details:"
            echo "$TASK_INFO" | jq '.tasks[0]'
            
            # Try to get CloudWatch logs
            CONTAINER_NAME="service"
            TASK_ID=$(echo "${TASK_ARN}" | rev | cut -d'/' -f1 | rev)
            LOG_GROUP="/ecs/${CLUSTER_NAME}"
            LOG_STREAM="ecs/${CONTAINER_NAME}/${TASK_ID}"
            
            echo "Attempting to fetch logs from ${LOG_GROUP}/${LOG_STREAM}..."
            aws logs get-log-events \
              --log-group-name "${LOG_GROUP}" \
              --log-stream-name "${LOG_STREAM}" \
              --limit 50 || echo "Could not fetch CloudWatch logs"
            
            exit 1
          fi

          echo "✅ Migrations completed successfully"

      - name: Promote image tag
        env:
          IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
        run: |
          docker pull ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG

          docker tag \
            ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG \
            ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:staging

          docker push \
            ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:staging

      - name: Deploy to ECS
        env:
          CLUSTER_NAME: ${{ steps.vars.outputs.cluster }}
          SERVICE_NAME: ${{ steps.vars.outputs.service }}
        run: |
          echo "Updating ECS service: ${SERVICE_NAME}"

          aws ecs update-service \
            --cluster "${CLUSTER_NAME}" \
            --service "${SERVICE_NAME}" \
            --force-new-deployment \
            --query 'service.serviceName' \
            --output text

          echo "Waiting for ECS service to stabilize..."
          aws ecs wait services-stable \
            --cluster "${CLUSTER_NAME}" \
            --services "${SERVICE_NAME}"

          echo "✅ Deployment completed successfully"

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/prod'
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set deployment variables
        id: vars
        run: |
          echo "cluster=prod" >> $GITHUB_OUTPUT
          echo "service=prod-service" >> $GITHUB_OUTPUT

      - name: Pull Docker image
        env:
          IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
        run: |
          docker pull ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG

      - name: Run database migrations
        env:
          IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
          CLUSTER_NAME: ${{ steps.vars.outputs.cluster }}
          SERVICE_NAME: ${{ steps.vars.outputs.service }}
        run: |
          # Option 1: Fetch from SSM and pass as environment variable (current approach)
          DB_STRING=$(aws ssm get-parameter \
            --name "/prod/service/postgres-url" \
            --with-decryption \
            --query 'Parameter.Value' \
            --output text)

          if [ -z "$DB_STRING" ]; then
            echo "❌ Failed to retrieve database connection string from SSM"
            exit 1
          fi

          echo "✅ Retrieved database connection string from SSM"

          # Create overrides file with environment variables
          cat > overrides.json <<EOF
          {
            "containerOverrides": [
              {
                "name": "service",
                "environment": [
                  { "name": "GOOSE_DRIVER", "value": "postgres" },
                  { "name": "GOOSE_DBSTRING", "value": "${DB_STRING}" }
                ],
                "command": ["goose", "-dir", "migrations", "up"]
              }
            ]
          }
          EOF
          
          # Alternative Option 2: Use ECS secrets (more secure - uncomment to use)
          # This requires your task execution role to have ssm:GetParameters permission
          # cat > overrides.json <<EOF
          # {
          #   "containerOverrides": [
          #     {
          #       "name": "service",
          #       "environment": [
          #         { "name": "GOOSE_DRIVER", "value": "postgres" }
          #       ],
          #       "secrets": [
          #         {
          #           "name": "GOOSE_DBSTRING",
          #           "valueFrom": "/prod/service/postgres-url"
          #         }
          #       ],
          #       "command": ["goose", "-dir", "migrations", "up"]
          #     }
          #   ]
          # }
          # EOF

          echo "Starting migration task..."
          
          # Run the migration task
          TASK_ARN=$(aws ecs run-task \
            --cluster "${CLUSTER_NAME}" \
            --task-definition "${SERVICE_NAME}" \
            --launch-type EC2 \
            --overrides file://overrides.json \
            --query 'tasks[0].taskArn' \
            --output text)

          echo "Migration task ARN: ${TASK_ARN}"

          # Check if task was created successfully
          if [ "$TASK_ARN" == "None" ] || [ -z "$TASK_ARN" ]; then
            echo "❌ Failed to start migration task"
            exit 1
          fi

          # Wait for the task to complete
          echo "Waiting for migration task to complete..."
          aws ecs wait tasks-stopped \
            --cluster "${CLUSTER_NAME}" \
            --tasks "${TASK_ARN}"

          # Get task exit code
          TASK_INFO=$(aws ecs describe-tasks \
            --cluster "${CLUSTER_NAME}" \
            --tasks "${TASK_ARN}")

          EXIT_CODE=$(echo "$TASK_INFO" | jq -r '.tasks[0].containers[0].exitCode // "None"')
          STOPPED_REASON=$(echo "$TASK_INFO" | jq -r '.tasks[0].stoppedReason // "Unknown"')
          LAST_STATUS=$(echo "$TASK_INFO" | jq -r '.tasks[0].lastStatus // "Unknown"')

          echo "Task Status: ${LAST_STATUS}"
          echo "Exit Code: ${EXIT_CODE}"
          echo "Stopped Reason: ${STOPPED_REASON}"

          # Check for task failure
          if [ "$EXIT_CODE" == "None" ] || [ "$EXIT_CODE" != "0" ]; then
            echo "❌ Migration failed"
            echo "Task details:"
            echo "$TASK_INFO" | jq '.tasks[0]'
            
            # Try to get CloudWatch logs
            CONTAINER_NAME="service"
            TASK_ID=$(echo "${TASK_ARN}" | rev | cut -d'/' -f1 | rev)
            LOG_GROUP="/ecs/${CLUSTER_NAME}"
            LOG_STREAM="ecs/${CONTAINER_NAME}/${TASK_ID}"
            
            echo "Attempting to fetch logs from ${LOG_GROUP}/${LOG_STREAM}..."
            aws logs get-log-events \
              --log-group-name "${LOG_GROUP}" \
              --log-stream-name "${LOG_STREAM}" \
              --limit 50 || echo "Could not fetch CloudWatch logs"
            
            exit 1
          fi

          echo "✅ Migrations completed successfully"

      - name: Promote image tag
        env:
          IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
        run: |
          docker pull ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG

          docker tag \
            ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG \
            ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:prod

          docker push \
            ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:prod

      - name: Deploy to ECS
        env:
          CLUSTER_NAME: ${{ steps.vars.outputs.cluster }}
          SERVICE_NAME: ${{ steps.vars.outputs.service }}
        run: |
          echo "Updating ECS service: ${SERVICE_NAME}"

          aws ecs update-service \
            --cluster "${CLUSTER_NAME}" \
            --service "${SERVICE_NAME}" \
            --force-new-deployment \
            --query 'service.serviceName' \
            --output text

          echo "Waiting for ECS service to stabilize..."
          aws ecs wait services-stable \
            --cluster "${CLUSTER_NAME}" \
            --services "${SERVICE_NAME}"

          echo "✅ Deployment completed successfully"